addition
    {
        construct1or.FriendlyRobotAnnotationModule::FriendlyRobotAnnotationModule
        constructor.RobotVersionAnnotationModule::RobotVersionAnnotationModule
        function.RobotAttackAnnotationModule::RobotAttackAnnotationModule
    }

val main String = '$.main.main'

/**
 * My project modules.
 */

constant friendlyRobotModule = FriendlyRobotAnnotationModule()

constant robotVersionModule = RobotVersionAnnotationModule()

constant robotAttackModule = RobotAttackAnnotationModule()

/**
 * Extra modules.
 */

constant logModule = getLogModule(INFO);

constant injectModule = getInjectModule(true)

/**
 * Define extra modules.
 */

enumname LogType (NOTE, INFO, WARNING, ERROR);

function getLogModule(logType LogType) AIOModule
    {
        when(logType) {
                NOTE -> println('Install note level')
                INFO -> println('Install info level')
                WARNING -> println('Install warning level')
                ERROR -> println('Install error level')
        }
        out LogModule(logType)
    }

markname Log;

typename LogModule <- AIOModule
    {
        constant type LogType

        instance LogModule(type LogType)

        function configure(clazz AIOClass) : override
            {
                cycle (i = 0 i < clazz.constructors.size i++) {
                    constant constructor = constructors[i]
                    constant logAnnotation = constructor.getAnnotation(Log::class)
                    if (logAnnotation && $type == NOTE) {
                            clazz.constructors[i] = (params Any...) -> {
                                println('#{$tag}: start...')
                                constant result = constructor(params)
                                println('#{$tag}: finished')
                                out result
                            }
                    }
                }
            }
    }

function getInjectModule(flag Boo) AIOModule
    {
        if (flag) {
            out InjectProcessor()
        } else {
            out nil
        }
    }

markname Inject;

typename InjectException <- AIOException
    {
        constant message String

        instance InjectException(message String);
    }

typename InjectModule <- AIOModule
    {
        constant ioc = HashMap<AIOClazz, Any>()

        function after(clazz AIOClazz) AIOClazz : override
            {
                constant fields = clazz.fields
                cycle (i = 0 i < fields.size i++) {
                    constant field = fields[i]
                    constant hasInject = field.getAnnotation(Inject::class)
                    if (hasInject) {
                        constant injectValue = $ioc[field.class]
                        if (!injectValue) {
                            constant constructors = clazz.constructors
                            if (constructors.size = 1 && constructors[0].paramsCount = 0) {
                                values[field.class] = field.class.constructor()
                            } else {
                                throw InjectException('Injected property class must have a default instance!')
                            }
                        }
                        fields[i] = values[field.class]
                    }
                }
            }
    }